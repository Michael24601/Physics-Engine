/*
	Header file for a contact, two objects in collision. All contacts are
	resolved by first removing any interpenetration (same as particles),
	and then by creating the necessary forces for a rebound effect.
	This class is also used to generate position joints, that keep objects
	a set distance apart, or close, or inhibits their rotation.
	There are several types of contacts, each generating different forces.
	These are point to face contact, edge to edge contact, edge to face
	contact, and face to face contact.
	In the point to face case, we ususally project the interpenetrating
	point onto the face, and then calculate the distance between them to
	get the interpenetration. The normal is the face's normal. (perpendicular
	vector). The contact point can be the point itself or a halfway
	point between the two.
	For an edge to edge contact, the normal is at right angles with the
	tangent of both edges (calculated using a vector product). The contact
	point is either the closed point on one edge to another, or the midway
	point between the two (the second is more accurate but also slower).
	For edge face contacts, we can get away with using another type of
	contact, except in the case of a curved surface. In that case, the normal
	can again be the normal of the face (ignoring the normal of the edge),
	Then depenging on the geometry, we can calculate the point of deepest
	penetration, and the depth as the length along the normal passing through
	the contact point, unless the depth was already calculated in trying to
	find said point.
	Again, for face to face contacts, we can use a different type of contact
	to generate it, unless of course the surface of either face is curved.
	In that case, The contact normals of both faces at the contact point are
	usually opposites, so we pick one and work on it. However, note that they
	can't be swapped in later frames when dealing with the collision, and the
	use of one over the othef should remain consistent. Then depenging on the
	geometry, we can calculate the point of deepest penetration, and the depth
	as the length along the normal passing through the contact point, unless
	the depth was already calculated in trying to find said point.
*/

#ifndef CONTACT_H
#define CONTACT_H

#include "vector3D.h"
#include "rigidBody.h"
#include "matrix3x3.h"
#include <assert.h>

namespace pe {

	class Contact {

	public:

		/*
			The two bodies in contact. The second can be null if the contact
			is with a piece of scenery.
		*/
		RigidBody* body[2];

		// Firction generated by contact
		real friction;

		// Restitution (bounciness) of contact
		real restitution;
		
		// Position of the contact point in world coordinates
		Vector3D contactPoint;
		
		// Direction of the contact, also in world coordinates
		Vector3D contactNormal;
		
		/*
			Holds the depth of the interpenetration of the two bodies. In
			that case, the contactPoint maybe be the coordinate of the
			halfway point between the two interpenetrating points.
		*/
		real penetration;


		/*
			In the same way that we can turn local rigid body coordinates
			into world coordinates, a contact has its own orthonormal
			basis, which we can transform into world coordinates.
			The basis has the x axis as the contact normal, and the y and
			z axes are at right angles to it.

			This matrix transforms the local contact coordinates into world
			coordinates. It is made up of three columns that form the
			orthonormal basis in world coordinates (the contact normal we
			have is stored in world coordinates of course, otherwise all
			contact normals would just be (1, 0, 0)).

			One thing to note is that, since the matrix represents a 
			transformation between one orthonormal base and another, there
			is no scaling or skewing. And since it is a 3 by 3 matrix, there
			is no translation either. That makes it a rotation matrix,
			meaning that its inverse is its transpose. So when we want to go
			from world to contact coordinates, we can use the transpose,
			instead of calculating the inverse from scratch, which is
			costlier.
		*/
		Matrix3x3 contactToWorld;


		/*
			Position of the contact in the local coordinates of each of
			the two bodies in contact (if there is a second body).
		*/
		Vector3D relativeContactPosition[2];


		/*
			The velocity needed to resolve the contacts based on the
			restitution and other variables.
		*/
		real desiredDeltaVelocity;


		/*
			The closing velocity of the two objects in contact coordinates.
		*/
		Vector3D contactVelocity;


		void applyPositionChange(
			Vector3D linearChange[2],
			Vector3D angularChange[2],
			real penetration
		);


		inline Vector3D calculateFrictionlessImpulse(
			Matrix3x3* inverseInertiaTensor
		);




		inline Vector3D calculateFrictionImpulse(
			Matrix3x3* inverseInertiaTensor
		);


		void applyVelocityChange(
			Vector3D velocityChange[2],
			Vector3D rotationChange[2]
		);


		/*
			If one of the bodies is null, then it needs to be the second
			one. If not, this function switches the two, and then switches
			the direction of the contact normal as it must always be
			relative to the first body.
		*/
		void swapBodies();


		/*
			Calculates the orthonormal basis of the contact based on the 
			contact normal.
			We could use the makeOrthonormalBasis function, but instead, we
			rewrite the logic in a more performant way.
		*/
		void calculateContactBasis();


		/*
			Calculates internal contact data at the start of the collision.
		*/
		void calculateInternals(real duration);


		/*
			Calculates the closing velocity of one of the two bodies (if the
			two bodies exist) in world coordinates.
		*/
		Vector3D calculateLocalVelocity(
			unsigned int bodyIndex,
			real duration
		);


		/*
			Calculates the desired delta velocity of the contact (the two
			bodies), all while considering the restitution coefficient.
			The result is given in contact coordinates.

			Desired delta velocity, unlike delta velocity, is not a
			a function of the collision position, or the body masses, but
			is instead the velocity that counters the closing velocity.
		*/
		void calculateDesiredDeltaVelocity(real duration);
	};
}

#endif
